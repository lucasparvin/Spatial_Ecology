---
title: "Project: Avian SDMs"
author: "Lucas Parvin"
date: "3-28-2024"
output:
  html_document:
    df_print: paged
---

# Load Packages

```{r, warning=F, error=F, message=F}
require(terra)
require(tidyterra)
require(sf)
require(adehabitatHR)
require(adehabitatLT)
require(adehabitatHS)
require(tidyverse)
require(survival)
require(geodata)
require(FedData)
require(tigris)
require(sampling)
require(dismo)
require(predicts)
require(ggnewscale)
require(mgcv)
require(randomForest)
require(maxnet)
require(enmSdmX)
require(gbm)
require(dplyr)

```


# Import Needed Data --> ## I SHOULD ADD TREE CANOPY & CHANGE TO ALL WMAs
```{r, warning=F, error=F, message=F}

visits <- read.csv("Tidy Tables/tidy_BirdLevel2_PointVisits.csv", header = T)
encounters <- read.csv("Tidy Tables/tidy_BirdLevel3_Encounters.csv", header = T)

# Merging 'visits' and 'encounters' data frames on 'PointID'
merged_data <- merge(visits, encounters, by = "PointID")
perdido_birds <- merged_data[merged_data$WMA == "PE", ]

# NOBO <- merged_data[merged_data$Species == "NOBO", ]
# NOBO_Unique_Points <- unique(NOBO$PointID)
# NOBO_Unique_WMAs <- unique(NOBO$WMA)
# NOBO_Unique_Points <- NOBO %>%
#   group_by(WMA) %>%
#   summarise(Unique_Points = n_distinct(PointID))
# print(NOBO_Unique_Points)

# Count the number of each species using dplyr
species_counts <- perdido_birds %>%
  group_by(Species) %>%
  summarise(count = n())

# Display the counts
print(species_counts)


perdido_birds <- perdido_birds[, -12] # Removes interval
perdido_birds$INBU <- ifelse(perdido_birds$Species == "INBU", 1, 0)

# Remove irrelevant covariates
INBU_pres_abs <- perdido_birds[, -c(3,4,5,7,8,11,12,13,14,15),]

# Reduce to unique rows based on all columns
INBU_pres_abs <- unique(INBU_pres_abs)

# Step 1: Arrange by PointID and INBU in descending order
# Step 2: Keep only unique rows based on PointID, keeping the first occurrence
INBU_pres_abs <- INBU_pres_abs %>%
  arrange(PointID, desc(INBU)) %>%
  distinct(PointID, .keep_all = TRUE)

INBU_pres_abs <- INBU_pres_abs[, -c(1:3)] #simplify to x, y, and 0/1

```

My code would not push to github when working with all WMAs because the commits were too large. Thus, I decide to just work with Perdido.

I went with INBU since they were one of the most abundant birds observed, but also not a bird that is overly abundant or a generalist. 



```{r}

# Load perdido
perdido <- st_read("Perdido_ICP1.shp") # Could put other shape files here
# Transform perdido to WGS 84 (EPSG:4326)
perdido <- st_transform(perdido, crs = "EPSG:4326")

# Plot
ggplot(data = perdido) +
  geom_sf() +
  theme_minimal() +
  ggtitle("Perdido")

# Convert 'perdido' to a terra SpatVector for compatibility with terra functions
perdido_vect <- vect(perdido)
crs_perdido <- crs(perdido_vect)

elevation <- get_ned(perdido_vect, label='Elevation')
elevation <- project(elevation, crs_perdido)
# elevation_raster <- writeRaster(elevation, 'elevation_reprojected.tif', overwrite=TRUE)

# Check CRS of both 'perdido' and 'elevation'
crs_perdido <- crs(perdido_vect)
crs_elevation <- crs(elevation)

# Print CRS information for both
print(crs_perdido)
print(crs_elevation)

```

```{r}
elevation_clipped <- crop(elevation, perdido_vect)
elevation_clipped <- mask(elevation_clipped, perdido_vect)
# Convert clipped elevation raster to a data frame for plotting
elevation_df <- as.data.frame(elevation_clipped, xy = TRUE)

# Plot using ggplot2
ggplot() +
  geom_raster(data = elevation_df, aes(x = x, y = y, fill = Layer_1)) +
  scale_fill_viridis_c() + # This uses a color gradient from the viridis package
  coord_fixed() + # Keep aspect ratio of the map consistent
  theme_minimal() +
  labs(title = "Clipped Elevation within Perdido", fill = "Elevation") +
  geom_sf(data = perdido, inherit.aes = FALSE, fill = NA, color = "black") # Overlay the 'perdido' boundary

```

```{r}
slope = terrain(elevation, v='slope', neighbors=8, unit='degrees')
slope_clipped <- crop(slope, perdido_vect)
slope_clipped <- mask(slope_clipped, perdido_vect)
# Convert clipped elevation raster to a data frame for plotting
slope_df <- as.data.frame(slope_clipped, xy = TRUE)

#terra::writeRaster(slope, 'slope.tif', overwrite=TRUE)
ggplot(slope_df, aes(x=x, y=y, fill=slope))+
  scale_fill_gradientn(colours = terrain.colors(7))+
  geom_raster()+
  coord_equal()+
  theme_bw()+
  theme(panel.grid=element_blank())



```

```{r}


aspect = terrain(elevation, v='aspect', neighbors=8, unit='degrees')


aspect_clipped <- crop(aspect, perdido_vect)
aspect_clipped <- mask(aspect_clipped, perdido_vect)


# Convert clipped elevation raster to a data frame for plotting
aspect_df <- as.data.frame(aspect_clipped, xy = TRUE)
#terra::writeRaster(aspect, 'aspect.tif', overwrite=TRUE)
ggplot(aspect_df, aes(x=x, y=y, fill=aspect))+
  scale_fill_gradientn(colours = terrain.colors(7))+
  geom_raster()+
  coord_equal()+
  theme_bw()+
  theme(panel.grid=element_blank())

```


```{r}

### CONVERT NLCD NUMBERS TO NAMES ###

nlcd2011 <- get_nlcd(perdido_vect, label='Landscape', year=2011)
nlcd2011 <- project(nlcd2011, crs_perdido )
nlcd2011 <- crop(nlcd2011, perdido_vect)
nlcd2011 <- mask(nlcd2011, perdido_vect)
terra::writeRaster(nlcd2011, 'nlcd.tif', overwrite=TRUE)
nlcd <- rast('nlcd.tif')
#####################
# Example codes for "Developed, Open Space", "Developed, Low Intensity", 
# and "Developed, Medium Intensity"
codes_to_na <- c(21, 22, 23)

# Creating a matrix for reclassification: From value, To value
reclass_matrix <- cbind(codes_to_na, rep(NA, length(codes_to_na)))

# Reclassify the raster
nlcd <- classify(nlcd, reclass_matrix, right=FALSE)

####################

land_cover_descriptions <- c(
  "11" = "Open Water",
  "12" = "Perennial Ice/Snow",
  "31" = "Barren Land",
  "41" = "Deciduous Forest",
  "42" = "Evergreen Forest",
  "43" = "Mixed Forest",
  "52" = "Shrub/Scrub",
  "71" = "Grassland/Herbaceous",
  "81" = "Pasture/Hay",
  "82" = "Cultivated Crops",
  "90" = "Woody Wetlands",
  "95" = "Emergent Herbaceous Wetlands"
)

# Convert the raster to a data frame
nlcd_df <- as.data.frame(nlcd, xy = TRUE, na.rm = TRUE)

# Map numeric codes to their descriptions
nlcd_df$Class <- factor(land_cover_descriptions[as.character(nlcd_df$Class)])

# Note: 'layer' should be replaced with the actual name of the raster layer in your data frame

ggplot(nlcd_df, aes(x = x, y = y, fill = Class)) +
  geom_raster() +
  scale_fill_viridis_d() +
  coord_fixed() +
  theme_minimal() +
  labs(title = "NLCD 2011 Land Cover within Perdido Area")

```
```{r}
# soil <- get_ssurgo(perdido_vect, label='soil')
# soil <- project(soil, crs_perdido )
# soil <- crop(soil, perdido_vect)
# soil <- mask(soil, perdido_vect)
# terra::writeRaster(soil, 'soil.tif', overwrite=TRUE)
# soil <- rast('soil.tif')
# 
# # Convert the NLCD raster to a dataframe
# soil_df <- as.data.frame(soil, xy = TRUE, na.rm = TRUE)
# 
# # Plotting the NLCD data
# ggplot(soil_df, aes(x = x, y = y, fill = Class)) +
#   geom_raster() +
#   scale_fill_viridis_d(begin = 0.3, end = 0.9, direction = -1, name = "soil") +
#   coord_fixed() +
#   theme_minimal() +
#   labs(title = "soil within Perdido Area")
```

```{r}
treecover <- rast('treecover.tif')
treecover <- project(treecover, crs_perdido )
treecover <- crop(treecover, perdido_vect)
treecover <- mask(treecover, perdido_vect)
# 
# # # Convert the NLCD raster to a dataframe
treecover_df <- as.data.frame(treecover, xy = TRUE, na.rm = TRUE)
# #
# # # Plotting the NLCD data
ggplot(treecover_df, aes(x = x, y = y, fill = treecover)) +
   geom_raster() +
   coord_fixed() +
   theme_minimal() +
   labs(title = "Tree Cover within Perdido Area")


```


```{r}

############### ADD TREE COVER WITHIN 1 KM #####################

# soil <- get_ssurgo(perdido_vect, label='soil')
# soil <- project(soil, crs_perdido )
# soil <- crop(soil, perdido_vect)
# soil <- mask(soil, perdido_vect)
# terra::writeRaster(soil, 'soil.tif', overwrite=TRUE)
# soil <- rast('soil.tif')
# 
# # Convert the NLCD raster to a dataframe
# soil_df <- as.data.frame(soil, xy = TRUE, na.rm = TRUE)
# 
# # Plotting the NLCD data
# ggplot(soil_df, aes(x = x, y = y, fill = Class)) +
#   geom_raster() +
#   scale_fill_viridis_d(begin = 0.3, end = 0.9, direction = -1, name = "soil") +
#   coord_fixed() +
#   theme_minimal() +
#   labs(title = "soil within Perdido Area")
```


```{r}

############### ADD TREE COVER WITHIN 1 KM #####################

# Assuming 'elevation', 'slope', 'aspect', and 'nlcd' are already loaded
# and 'elevation' is the standard for resolution and extent

res_standard <- res(elevation)  # Standard resolution
ext_standard <- ext(elevation)  # Standard extent

# Resample and align slope
slope_aligned <- resample(slope, elevation, method="bilinear")
slope_aligned <- crop(slope_aligned, ext_standard)
slope_aligned <- mask(slope_aligned, perdido_vect)

# Resample and align aspect
aspect_aligned <- resample(aspect, elevation, method="bilinear")
aspect_aligned <- crop(aspect_aligned, ext_standard)
aspect_aligned <- mask(aspect_aligned, perdido_vect)

# Resample and align elevation ### SEEMS UNNEEDED ####
elevation_aligned <- resample(elevation, elevation, method="bilinear")
elevation_aligned <- crop(elevation_aligned, ext_standard)
elevation_aligned <- mask(elevation_aligned, perdido_vect)

# Resample and align nlcd
nlcd_aligned <- resample(nlcd, elevation_aligned, method="near")
nlcd_aligned <- crop(nlcd_aligned, ext_standard)
nlcd_aligned <- mask(nlcd_aligned, perdido_vect)

# Resample and align tree cover
tree_aligned <- resample(treecover, elevation_aligned, method="near")
tree_aligned <- crop(tree_aligned, ext_standard)
tree_aligned <- mask(tree_aligned, perdido_vect)
```

```{r}

covariates = c(elevation_aligned, aspect_aligned, slope_aligned, nlcd_aligned, tree_aligned)
names(covariates) = c('elevation', 'aspect', 'slope', 'NLCD', 'treecover')

coords = cbind(INBU_pres_abs$Longitude, INBU_pres_abs$Latitude)
pres_abs_Covs = terra::extract(covariates, coords)

```


# Bind INBU presence absence data with covariates
```{r}
INBU_and_Covs = cbind(pres_abs_Covs, INBU_pres_abs)

```

# Correlation between covariates
```{r} 
# MOVE THIS TO HIGHER UP
pairs(covariates, maxpixels=1000)






```



# GLMs
```{r}

glm_intecept = glm(INBU ~ 1, family = 'binomial', data = INBU_and_Covs)
glm_nlcd = glm(INBU ~ NLCD, family = 'binomial', data = INBU_and_Covs)
glm_all = glm(INBU ~ NLCD + treecover + elevation + slope + aspect, family = 'binomial', data = INBU_and_Covs)
glm_interaction = glm(INBU ~ NLCD*elevation, family = 'binomial', data = INBU_and_Covs)
glm_nohab = glm(INBU ~ elevation + slope + aspect, family = 'binomial', data = INBU_and_Covs)
glm_elevtree = glm(INBU ~ treecover + elevation, family = 'binomial', data = INBU_and_Covs)
glm_elevtreeslope = glm(INBU ~ elevation + treecover + slope, family = 'binomial', data = INBU_and_Covs)
```

# Comparing GLMs
```{r}

aic_intercept <- AIC(glm_intecept)
aic_nlcd <- AIC(glm_nlcd)
aic_all <- AIC(glm_all)
aic_interaction <- AIC(glm_interaction)
aic_nohab <- AIC(glm_nohab)
aic_elevtree <- AIC(glm_elevtree)
aic_elevtreeslope <- AIC(glm_elevtreeslope)


min_aic <- min(aic_intercept, aic_nlcd, aic_all, aic_interaction, aic_nohab, aic_elevtree, aic_elevtreeslope)


delta_aic_intercept <- aic_intercept - min_aic
delta_aic_nlcd <- aic_nlcd - min_aic
delta_aic_all <- aic_all - min_aic
delta_aic_interaction <- aic_interaction - min_aic
delta_aic_nohab <- aic_nohab - min_aic
delta_aic_elevtree <- aic_elevtree - min_aic
delta_aic_elevtreeslope <- aic_elevtreeslope - min_aic

summary_table <- data.frame(
  Model = c("glm_intecept", "glm_nlcd", "glm_all", "glm_interaction", "glm_nohab", "glm_elevtree", "glm_elevtreeslope"),
  AIC = c(aic_intercept, aic_nlcd, aic_all, aic_interaction, aic_nohab, aic_elevtree, aic_elevtreeslope),
  Delta_AIC = c(delta_aic_intercept, delta_aic_nlcd, delta_aic_all, delta_aic_interaction, delta_aic_nohab, delta_aic_elevtree, delta_aic_elevtreeslope)
)

print(summary_table)


summary(glm_all)
summary(glm_intecept)
summary(glm_nohab)
summary(glm_interaction)
summary(glm_nlcd)
summary(glm_elevtree)
summary(glm_elevtreeslope)

```

Elevation, tree cover, and slope seem like the strongest predictor, consistently.


# Predict across Perdido
```{r}


predRaster = predict(model = glm_elevtreeslope, object = covariates)
predRaster = exp(predRaster)/(1+exp(predRaster))
plot(predRaster)


## I think this error is occurring due to the fact that there are NLCD values of developed, open space, etc. in the "covariates" object, but these cover types are absent from the INBU_and_Covs data frame, from which the GLMs are built. Thus, I have to either remove pixels with these cover types from the get-go OR figure out a way to just NOT predict to these cover types in predRaster. If I remove these pixels from the get-go, I will need to align the elevation, slope, and aspect rasters to the NLCD raster (essentially punching holes in those rasters) in order for each raster to stack properly. What is the best way to approach this? How can I do it?

```

# GAMs
```{r}
# using elevation tree cover and slope
gam_elevtreeslope = gam(INBU ~ s(treecover, k=3) + s(elevation, k=3) + s(slope, k=3), family='binomial', data = INBU_and_Covs, method='ML')
summary(gam_elevtreeslope)

gamMap = predict(covariates, gam_elevtreeslope, type='response')

plot(gamMap)

```
# Boosted Regression Trees
```{r}
set.seed(2024)
boostModel = gbm(INBU ~ elevation + treecover + slope, distribution='bernoulli', n.trees=100, interaction.depth=2, shrinkage=0.1, bag.fraction=0.5, data=INBU_and_Covs)

boostMap = predict(covariates, boostModel, type='response')
#plot(boostMap)

boostMap = mask(boostMap, covariates$NLCD) # to clip to perdido
plot(boostMap)
```
# Random Forests
```{r}
set.seed(2024)

tuneRF(y = as.factor(INBU_and_Covs$INBU), x=INBU_and_Covs[, c(1,3,5)], stepFactor = 2, ntreeTry = 500)

# mtry 1 is best

rfModel = randomForest(as.factor(INBU) ~ elevation + + treecover + slope, data=INBU_and_Covs, mtry=1, ntree=500, na.action = na.omit)

rfMap = predict(covariates, rfModel, type='prob', index=2)
plot(rfMap)

```
# Maximum Entropy
```{r}
pbVect = INBU_and_Covs$INBU
covs <- INBU_and_Covs %>% dplyr::select(c('elevation', 'treecover', 'slope'))

maxentModel = maxnet(p = pbVect,
                     data= covs,
                     regmult = 1,
                     classes='lqpht')
?maxnet

plot(maxentModel, type='logistic')

maxentMap = predictMaxNet(maxentModel, covariates, type='logistic')

par(mfrow=c(1,1))
plot(maxentMap)

```
# Comparing Parameter Estimates
```{r}
tmp = expand.grid(
  elevation = seq(min(INBU_and_Covs$elevation), max(INBU_and_Covs$elevation), length = 1000),
  treecover = mean(INBU_and_Covs$treecover),
  slope = mean(INBU_and_Covs$slope)
)

elevData = data.frame(
  glm = predict(glm_elevtreeslope, tmp),
  gam = predict(gam_elevtreeslope, tmp, type = 'response'),
  boost = predict(boostModel, tmp, type = 'response'),
  rf = predict(rfModel, tmp, type = 'prob')[, 2],
  maxent = predict(maxentModel, tmp, type = 'logistic')[, 1]
) %>% 
  cbind(tmp) %>% 
  dplyr::select(glm:maxent, elevation) %>% 
  pivot_longer(cols = glm:maxent) %>% 
  mutate(variable = 'elevation')

```

```{r}
# Elevation
tmp = expand.grid(
  elevation = seq(min(INBU_and_Covs$elevation), max(INBU_and_Covs$elevation), length = 1000),
  treecover = mean(INBU_and_Covs$treecover),
  slope = mean(INBU_and_Covs$slope)
)

elevData = data.frame(
  glm = predict(glm_elevtreeslope, tmp),
  gam = predict(gam_elevtreeslope, tmp, type = 'response'),
  boost = predict(boostModel, tmp, type = 'response'),
  rf = predict(rfModel, tmp, type = 'prob')[, 2],
  maxent = predict(maxentModel, tmp, type = 'logistic')[, 1]
) %>% 
  cbind(tmp) %>% 
  dplyr::select(glm:maxent, elevation) %>% 
  pivot_longer(cols = glm:maxent) %>% 
  mutate(variable = 'elevation')

```

```{r}
# Tree Cover
tmp = expand.grid(elevation = mean(INBU_and_Covs$elevation),
                  treecover = seq(min(INBU_and_Covs$treecover), max(INBU_and_Covs$treecover), length=1000),
                  slope = mean(INBU_and_Covs$slope))

TreeCoverData = data.frame(
  glm = predict(glm_elevtreeslope, tmp),
  gam = predict(gam_elevtreeslope, tmp, type = 'response'),
  boost = predict(boostModel, tmp, type = 'response'),
  rf = predict(rfModel, tmp, type = 'prob')[, 2],
  maxent = predict(maxentModel, tmp, type = 'logistic')[, 1]
) %>% 
  cbind(tmp) %>% 
  dplyr::select(glm:maxent, treecover) %>% 
  pivot_longer(cols = glm:maxent) %>% 
  mutate(variable = 'treecover')
```

```{r}
# Slope
tmp = expand.grid(elevation = mean(INBU_and_Covs$elevation),
                  treecover = mean(INBU_and_Covs$treecover),
                  slope = seq(min(INBU_and_Covs$slope), max(INBU_and_Covs$slope), length=1000))

SlopeData = data.frame(
  glm = predict(glm_elevtreeslope, tmp),
  gam = predict(gam_elevtreeslope, tmp, type = 'response'),
  boost = predict(boostModel, tmp, type = 'response'),
  rf = predict(rfModel, tmp, type = 'prob')[, 2],
  maxent = predict(maxentModel, tmp, type = 'logistic')[, 1]
) %>% 
  cbind(tmp) %>% 
  dplyr::select(glm:maxent, slope) %>% 
  pivot_longer(cols = glm:maxent) %>% 
  mutate(variable = 'slope')
```
```{r}
colnames(elevData)[1] = colnames(TreeCoverData)[1] = colnames(SlopeData)[1] = 'xValue'

tmp = rbind(elevData, TreeCoverData, SlopeData)

ggplot(tmp, aes(x=xValue, y=value, color=name))+
  facet_wrap(~variable, scales='free_x')+
  geom_line()+
  theme_bw()+
  theme(panel.grid=element_blank())


```


# SDM Validation

```{r}

tmp <- covs %>% 
  mutate(INBU = INBU_and_Covs$INBU)

valData = data.frame('ID' = 1:nrow(tmp)) %>% 
  mutate(obs = tmp$INBU,
         glmVal = predict(glm_elevtreeslope, tmp %>% dplyr::select(elevation:slope), type='response'),
         gamVal = predict(gam_elevtreeslope, tmp %>% dplyr::select(elevation:slope), type='response'),
         boostVal = predict(boostModel, tmp %>% dplyr::select(elevation:slope), type='response'),
         rfVal = predict(rfModel, tmp %>% dplyr::select(elevation:slope), type='prob')[,2],
         maxentVal = predict(maxentModel, tmp %>% dplyr::select(elevation:slope), type='logistic')[,1])





```