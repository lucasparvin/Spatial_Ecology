---
title: "Project: Avian SDMs"
author: "Lucas Parvin"
date: "3-28-2024"
output:
  html_document:
    df_print: paged
---

# Load Packages

```{r, warning=F, error=F, message=F}
require(terra)
require(tidyterra)
require(sf)
require(adehabitatHR)
require(adehabitatLT)
require(adehabitatHS)
require(tidyverse)
require(survival)
require(geodata)
require(FedData)
require(tigris)
require(sampling)

```


# Import Needed Data
```{r, warning=F, error=F, message=F}

visits <- read.csv("Tidy Tables/tidy_BirdLevel2_PointVisits.csv", header = T)
encounters <- read.csv("Tidy Tables/tidy_BirdLevel3_Encounters.csv", header = T)

# Merging 'visits' and 'encounters' data frames on 'PointID'
merged_data <- merge(visits, encounters, by = "PointID")
perdido_birds <- merged_data[merged_data$WMA == "PE", ]

# Count the number of each species using dplyr
species_counts <- perdido_birds %>%
  group_by(Species) %>%
  summarise(count = n())

# Display the counts
print(species_counts)


perdido_birds <- perdido_birds[, -12] # Removes interval
perdido_birds$INBU <- ifelse(perdido_birds$Species == "INBU", 1, 0)

# Remove irrelevant covariates
INBU_pres_abs <- perdido_birds[, -c(3,4,5,7,8,11,12,13,14,15),]

# Reduce to unique rows based on all columns
INBU_pres_abs <- unique(INBU_pres_abs)

# Step 1: Arrange by PointID and INBU in descending order
# Step 2: Keep only unique rows based on PointID, keeping the first occurrence
INBU_pres_abs <- INBU_pres_abs %>%
  arrange(PointID, desc(INBU)) %>%
  distinct(PointID, .keep_all = TRUE)

INBU_pres_abs <- INBU_pres_abs[, -c(1:3)] #simplify to x, y, and 0/1

```

```{r}

# Load perdido
perdido <- st_read("Perdido_ICP1.shp")
# Transform perdido to WGS 84 (EPSG:4326)
perdido <- st_transform(perdido, crs = "EPSG:4326")

# Plot
ggplot(data = perdido) +
  geom_sf() +
  theme_minimal() +
  ggtitle("Perdido")

# Convert 'perdido' to a terra SpatVector for compatibility with terra functions
perdido_vect <- vect(perdido)
crs_perdido <- crs(perdido_vect)

elevation <- get_ned(perdido_vect, label='Elevation')
elevation <- project(elevation, crs_perdido)
elevation_raster <- writeRaster(elevation, 'elevation_reprojected.tif', overwrite=TRUE)

# Check CRS of both 'perdido' and 'elevation'
crs_perdido <- crs(perdido_vect)
crs_elevation <- crs(elevation)

# Print CRS information for both
print(crs_perdido)
print(crs_elevation)

```

```{r}
elevation_clipped <- crop(elevation, perdido_vect)
elevation_clipped <- mask(elevation_clipped, perdido_vect)
# Convert clipped elevation raster to a data frame for plotting
elevation_df <- as.data.frame(elevation_clipped, xy = TRUE)

# Plot using ggplot2
ggplot() +
  geom_raster(data = elevation_df, aes(x = x, y = y, fill = Layer_1)) +
  scale_fill_viridis_c() + # This uses a color gradient from the viridis package
  coord_fixed() + # Keep aspect ratio of the map consistent
  theme_minimal() +
  labs(title = "Clipped Elevation within Perdido", fill = "Elevation") +
  geom_sf(data = perdido, inherit.aes = FALSE, fill = NA, color = "black") # Overlay the 'perdido' boundary

```

```{r}
slope = terrain(elevation, v='slope', neighbors=8, unit='degrees')
slope_clipped <- crop(slope, perdido_vect)
slope_clipped <- mask(slope_clipped, perdido_vect)
# Convert clipped elevation raster to a data frame for plotting
slope_df <- as.data.frame(slope_clipped, xy = TRUE)

#terra::writeRaster(slope, 'slope.tif', overwrite=TRUE)
ggplot(slope_df, aes(x=x, y=y, fill=slope))+
  scale_fill_gradientn(colours = terrain.colors(7))+
  geom_raster()+
  coord_equal()+
  theme_bw()+
  theme(panel.grid=element_blank())



```

```{r}


aspect = terrain(elevation, v='aspect', neighbors=8, unit='degrees')


aspect_clipped <- crop(aspect, perdido_vect)
aspect_clipped <- mask(aspect_clipped, perdido_vect)


# Convert clipped elevation raster to a data frame for plotting
aspect_df <- as.data.frame(aspect_clipped, xy = TRUE)
#terra::writeRaster(aspect, 'aspect.tif', overwrite=TRUE)
ggplot(aspect_df, aes(x=x, y=y, fill=aspect))+
  scale_fill_gradientn(colours = terrain.colors(7))+
  geom_raster()+
  coord_equal()+
  theme_bw()+
  theme(panel.grid=element_blank())

```



```{r}

nlcd2011 <- get_nlcd(perdido_vect, label='Landscape', year=2011)
nlcd2011 <- project(nlcd2011, crs_perdido )
nlcd2011 <- crop(nlcd2011, perdido_vect)
nlcd2011 <- mask(nlcd2011, perdido_vect)
terra::writeRaster(nlcd2011, 'nlcd.tif', overwrite=TRUE)
nlcd <- rast('nlcd.tif')

# Convert the NLCD raster to a dataframe
nlcd_df <- as.data.frame(nlcd, xy = TRUE, na.rm = TRUE)

# Plotting the NLCD data
ggplot(nlcd_df, aes(x = x, y = y, fill = Class)) +
  geom_raster() +
  scale_fill_viridis_d(begin = 0.3, end = 0.9, direction = -1, name = "Land Cover") +
  coord_fixed() +
  theme_minimal() +
  labs(title = "NLCD 2011 Land Cover within Perdido Area")




```



```{r}
# Assuming 'elevation', 'slope', 'aspect', and 'nlcd' are already loaded
# and 'elevation' is the standard for resolution and extent

res_standard <- res(elevation)  # Standard resolution
ext_standard <- ext(elevation)  # Standard extent

# Resample and align slope
slope_aligned <- resample(slope, elevation, method="bilinear")
slope_aligned <- crop(slope_aligned, ext_standard)
slope_aligned <- mask(slope_aligned, perdido_vect)

# Resample and align aspect
aspect_aligned <- resample(aspect, elevation, method="bilinear")
aspect_aligned <- crop(aspect_aligned, ext_standard)
aspect_aligned <- mask(aspect_aligned, perdido_vect)

# Resample and align elevation
elevation_aligned <- resample(elevation, elevation, method="bilinear")
elevation_aligned <- crop(elevation_aligned, ext_standard)
elevation_aligned <- mask(elevation_aligned, perdido_vect)

# Assuming 'nlcd2011' is already aligned to 'perdido_vect' as per your setup,
# If 'nlcd2011' needs to be aligned to 'elevation' in terms of resolution:
nlcd_aligned <- resample(nlcd2011, elevation_aligned, method="near")
nlcd_aligned <- crop(nlcd_aligned, ext_standard)
nlcd_aligned <- mask(nlcd_aligned, perdido_vect)
```

```{r}

covariates = c(elevation_aligned, aspect_aligned, slope_aligned, nlcd_aligned)
names(covariates) = c('elevation', 'aspect', 'slope', 'NLCD')

coords = cbind(INBU_pres_abs$Longitude, INBU_pres_abs$Latitude)
landCovs = terra::extract(covariates, coords)



```




```{r}


# Stack aligned rasters
# Combine the rasters into a list and then create a stack
aligned_stack <- rast(c(elevation_aligned, slope_aligned, aspect_aligned, nlcd_aligned))

# Now, 'aligned_stack' is a SpatRaster that contains all the aligned layers

# Convert the raster stack to a data frame
stack_df <- as.data.frame(aligned_stack, xy = TRUE, na.rm = TRUE)



ext(elevation_aligned)==ext(nlcd_aligned) & ext(slope_aligned)==ext(aspect_aligned) & ext(nlcd_aligned) == ext(slope_aligned)


all(res(elevation_aligned)) == all(res(nlcd_aligned)) & all(res(slope_aligned)) == all(res(aspect_aligned)) & all(res(nlcd_aligned)) == all(res(slope_aligned))

crs(elevation_aligned) == crs(nlcd_aligned)
crs(elevation_aligned) == crs(slope_aligned) & crs(slope_aligned) == crs(aspect_aligned)


plot(elevation_aligned)
plot(slope_aligned)
plot(aspect_aligned)
plot(nlcd_aligned)





```





```{r}


```