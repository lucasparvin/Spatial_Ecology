---
title: "Project: Avian SDMs"
author: "Lucas Parvin"
date: "3-28-2024"
output:
  html_document:
    df_print: paged
---

# Load Packages

```{r, warning=F, error=F, message=F}
require(terra)
require(tidyterra)
require(sf)
require(adehabitatHR)
require(adehabitatLT)
require(adehabitatHS)
require(tidyverse)
require(survival)
require(geodata)
require(FedData)
require(tigris)
require(sampling)

```


# Import Needed Data --> ## I SHOULD ADD TREE CANOPY
```{r, warning=F, error=F, message=F}

visits <- read.csv("Tidy Tables/tidy_BirdLevel2_PointVisits.csv", header = T)
encounters <- read.csv("Tidy Tables/tidy_BirdLevel3_Encounters.csv", header = T)

# Merging 'visits' and 'encounters' data frames on 'PointID'
merged_data <- merge(visits, encounters, by = "PointID")
perdido_birds <- merged_data[merged_data$WMA == "PE", ]

# Count the number of each species using dplyr
species_counts <- perdido_birds %>%
  group_by(Species) %>%
  summarise(count = n())

# Display the counts
print(species_counts)


perdido_birds <- perdido_birds[, -12] # Removes interval
perdido_birds$INBU <- ifelse(perdido_birds$Species == "INBU", 1, 0)

# Remove irrelevant covariates
INBU_pres_abs <- perdido_birds[, -c(3,4,5,7,8,11,12,13,14,15),]

# Reduce to unique rows based on all columns
INBU_pres_abs <- unique(INBU_pres_abs)

# Step 1: Arrange by PointID and INBU in descending order
# Step 2: Keep only unique rows based on PointID, keeping the first occurrence
INBU_pres_abs <- INBU_pres_abs %>%
  arrange(PointID, desc(INBU)) %>%
  distinct(PointID, .keep_all = TRUE)

INBU_pres_abs <- INBU_pres_abs[, -c(1:3)] #simplify to x, y, and 0/1

```

My code would not push to github when working with all WMAs because the commits were too large. Thus, I decide to just work with Perdido.

I went with INBU since they were one of the most abundant birds observed, but also not a bird that is overly abundant or a generalist. 



```{r}

# Load perdido
perdido <- st_read("Perdido_ICP1.shp")
# Transform perdido to WGS 84 (EPSG:4326)
perdido <- st_transform(perdido, crs = "EPSG:4326")

# Plot
ggplot(data = perdido) +
  geom_sf() +
  theme_minimal() +
  ggtitle("Perdido")

# Convert 'perdido' to a terra SpatVector for compatibility with terra functions
perdido_vect <- vect(perdido)
crs_perdido <- crs(perdido_vect)

elevation <- get_ned(perdido_vect, label='Elevation')
elevation <- project(elevation, crs_perdido)
elevation_raster <- writeRaster(elevation, 'elevation_reprojected.tif', overwrite=TRUE)

# Check CRS of both 'perdido' and 'elevation'
crs_perdido <- crs(perdido_vect)
crs_elevation <- crs(elevation)

# Print CRS information for both
print(crs_perdido)
print(crs_elevation)

```

```{r}
elevation_clipped <- crop(elevation, perdido_vect)
elevation_clipped <- mask(elevation_clipped, perdido_vect)
# Convert clipped elevation raster to a data frame for plotting
elevation_df <- as.data.frame(elevation_clipped, xy = TRUE)

# Plot using ggplot2
ggplot() +
  geom_raster(data = elevation_df, aes(x = x, y = y, fill = Layer_1)) +
  scale_fill_viridis_c() + # This uses a color gradient from the viridis package
  coord_fixed() + # Keep aspect ratio of the map consistent
  theme_minimal() +
  labs(title = "Clipped Elevation within Perdido", fill = "Elevation") +
  geom_sf(data = perdido, inherit.aes = FALSE, fill = NA, color = "black") # Overlay the 'perdido' boundary

```

```{r}
slope = terrain(elevation, v='slope', neighbors=8, unit='degrees')
slope_clipped <- crop(slope, perdido_vect)
slope_clipped <- mask(slope_clipped, perdido_vect)
# Convert clipped elevation raster to a data frame for plotting
slope_df <- as.data.frame(slope_clipped, xy = TRUE)

#terra::writeRaster(slope, 'slope.tif', overwrite=TRUE)
ggplot(slope_df, aes(x=x, y=y, fill=slope))+
  scale_fill_gradientn(colours = terrain.colors(7))+
  geom_raster()+
  coord_equal()+
  theme_bw()+
  theme(panel.grid=element_blank())



```

```{r}


aspect = terrain(elevation, v='aspect', neighbors=8, unit='degrees')


aspect_clipped <- crop(aspect, perdido_vect)
aspect_clipped <- mask(aspect_clipped, perdido_vect)


# Convert clipped elevation raster to a data frame for plotting
aspect_df <- as.data.frame(aspect_clipped, xy = TRUE)
#terra::writeRaster(aspect, 'aspect.tif', overwrite=TRUE)
ggplot(aspect_df, aes(x=x, y=y, fill=aspect))+
  scale_fill_gradientn(colours = terrain.colors(7))+
  geom_raster()+
  coord_equal()+
  theme_bw()+
  theme(panel.grid=element_blank())

```



```{r}

nlcd2011 <- get_nlcd(perdido_vect, label='Landscape', year=2011)
nlcd2011 <- project(nlcd2011, crs_perdido )
nlcd2011 <- crop(nlcd2011, perdido_vect)
nlcd2011 <- mask(nlcd2011, perdido_vect)
terra::writeRaster(nlcd2011, 'nlcd.tif', overwrite=TRUE)
nlcd <- rast('nlcd.tif')

# Convert the NLCD raster to a dataframe
nlcd_df <- as.data.frame(nlcd, xy = TRUE, na.rm = TRUE)

# Plotting the NLCD data
ggplot(nlcd_df, aes(x = x, y = y, fill = Class)) +
  geom_raster() +
  scale_fill_viridis_d(begin = 0.3, end = 0.9, direction = -1, name = "Land Cover") +
  coord_fixed() +
  theme_minimal() +
  labs(title = "NLCD 2011 Land Cover within Perdido Area")




```
```{r}
# soil <- get_ssurgo(perdido_vect, label='soil')
# soil <- project(soil, crs_perdido )
# soil <- crop(soil, perdido_vect)
# soil <- mask(soil, perdido_vect)
# terra::writeRaster(soil, 'soil.tif', overwrite=TRUE)
# soil <- rast('soil.tif')
# 
# # Convert the NLCD raster to a dataframe
# soil_df <- as.data.frame(soil, xy = TRUE, na.rm = TRUE)
# 
# # Plotting the NLCD data
# ggplot(soil_df, aes(x = x, y = y, fill = Class)) +
#   geom_raster() +
#   scale_fill_viridis_d(begin = 0.3, end = 0.9, direction = -1, name = "soil") +
#   coord_fixed() +
#   theme_minimal() +
#   labs(title = "soil within Perdido Area")
```


```{r}
# Assuming 'elevation', 'slope', 'aspect', and 'nlcd' are already loaded
# and 'elevation' is the standard for resolution and extent

res_standard <- res(elevation)  # Standard resolution
ext_standard <- ext(elevation)  # Standard extent

# Resample and align slope
slope_aligned <- resample(slope, elevation, method="bilinear")
slope_aligned <- crop(slope_aligned, ext_standard)
slope_aligned <- mask(slope_aligned, perdido_vect)

# Resample and align aspect
aspect_aligned <- resample(aspect, elevation, method="bilinear")
aspect_aligned <- crop(aspect_aligned, ext_standard)
aspect_aligned <- mask(aspect_aligned, perdido_vect)

# Resample and align elevation
elevation_aligned <- resample(elevation, elevation, method="bilinear")
elevation_aligned <- crop(elevation_aligned, ext_standard)
elevation_aligned <- mask(elevation_aligned, perdido_vect)

# Assuming 'nlcd2011' is already aligned to 'perdido_vect' as per your setup,
# If 'nlcd2011' needs to be aligned to 'elevation' in terms of resolution:
nlcd_aligned <- resample(nlcd2011, elevation_aligned, method="near")
nlcd_aligned <- crop(nlcd_aligned, ext_standard)
nlcd_aligned <- mask(nlcd_aligned, perdido_vect)
```

```{r}

covariates = c(elevation_aligned, aspect_aligned, slope_aligned, nlcd_aligned)
names(covariates) = c('elevation', 'aspect', 'slope', 'NLCD')

coords = cbind(INBU_pres_abs$Longitude, INBU_pres_abs$Latitude)
pres_abs_Covs = terra::extract(covariates, coords)

```


# Bind INBU presence absence data with covariates
```{r}
INBU_and_Covs = cbind(pres_abs_Covs, INBU_pres_abs)

```

# GLMs
```{r}

glm_intecept = glm(INBU ~ 1, family = 'binomial', data = INBU_and_Covs)
glm_nlcd = glm(INBU ~ NLCD, family = 'binomial', data = INBU_and_Covs)
glm_all = glm(INBU ~ NLCD + elevation + slope + aspect, family = 'binomial', data = INBU_and_Covs)
glm_interaction = glm(INBU ~ NLCD*elevation, family = 'binomial', data = INBU_and_Covs)
glm_nohab = glm(INBU ~ elevation + slope + aspect, family = 'binomial', data = INBU_and_Covs)

aic_intercept <- AIC(glm_intecept)
aic_nlcd <- AIC(glm_nlcd)
aic_all <- AIC(glm_all)
aic_interaction <- AIC(glm_interaction)
aic_nohab <- AIC(glm_nohab)


min_aic <- min(aic_intercept, aic_nlcd, aic_all, aic_interaction, aic_nohab)


delta_aic_intercept <- aic_intercept - min_aic
delta_aic_nlcd <- aic_nlcd - min_aic
delta_aic_all <- aic_all - min_aic
delta_aic_interaction <- aic_interaction - min_aic
delta_aic_nohab <- aic_nohab - min_aic


summary_table <- data.frame(
  Model = c("glm_intecept", "glm_nlcd", "glm_all", "glm_interaction", "glm_nohab"),
  AIC = c(aic_intercept, aic_nlcd, aic_all, aic_interaction, aic_nohab),
  Delta_AIC = c(delta_aic_intercept, delta_aic_nlcd, delta_aic_all, delta_aic_interaction, delta_aic_nohab)
)

print(summary_table)


```

# Predict across Perdido
```{r}
predRaster = predict(model = glm_all, object = covariates)
predRaster = exp(predRaster)/(1+exp(predRaster))
plot(predRaster)


## I think this error is occurring due to the fact that there are NLCD values of developed, open space, etc. in the "covariates" object, but these cover types are absent from the INBU_and_Covs data frame, from which the GLMs are built. Thus, I have to either remove pixels with these cover types from the get-go OR figure out a way to just NOT predict to these cover types in predRaster. If I remove these pixels from the get-go, I will need to align the elevation, slope, and aspect rasters to the NLCD raster (essentially punching holes in those rasters) in order for each raster to stack properly. What is the best way to approach this? How can I do it?

```





# Envelope Models
```{r}



```


# GAMs
```{r}


```

# Maxent
```{r}


```