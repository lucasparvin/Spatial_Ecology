---
title: "R Notebook"
output: html_notebook
---

```{r}
# Load Packages
require(tidyterra)
require(dismo)
require(tidyverse)
require(terra)
require(predicts)
require(ggnewscale)
require(mgcv)
require(randomForest)
require(maxnet)
require(enmSdmX)
require(gbm)
require(patchwork)
#add any others needed
```



# Challenge 1 (4 points)

In the lab, we created 6 species distribution models (SDMs) for the same species using 6 different techniques. Plot the maps generated from (1) the bioclim envelope function, (2) the GLM model, and (3) the random forest model next to one another. What similarities and differences do you notice among these maps? What might explain some of these differences?

```{r}
# Loading the relevant data using the same code used in the lab

vathData = read.csv('https://raw.githubusercontent.com/ValenteJJ/SpatialEcology/main/Week8/vath_2004.csv')

vathPres = vathData %>% filter(VATH==1)
vathAbs = vathData %>% filter(VATH==0)

vathPresXy = as.matrix(vathPres %>% select(EASTING, NORTHING))
vathAbsXy = as.matrix(vathAbs %>% select(EASTING, NORTHING))


vathVal = read.csv('https://raw.githubusercontent.com/ValenteJJ/SpatialEcology/main/Week8/vath_VALIDATION.csv')

vathValPres = vathVal %>% filter(VATH==1)
vathValAbs = vathVal %>% filter(VATH==0)

vathValXy = as.matrix(vathVal %>% select(EASTING, NORTHING))
vathValPresXy = as.matrix(vathValPres %>% select(EASTING, NORTHING))
vathValAbsXy = as.matrix(vathValAbs %>% select(EASTING, NORTHING))

elev = rast('https://github.com/ValenteJJ/SpatialEcology/raw/main/Week8/elevation.tif')
canopy = rast('https://github.com/ValenteJJ/SpatialEcology/raw/main/Week8/canopy.tif')
mesic = rast('https://github.com/ValenteJJ/SpatialEcology/raw/main/Week8/mesic.tif')
precip = rast('https://github.com/ValenteJJ/SpatialEcology/raw/main/Week8/precip.tif')

crs(elev) = crs(mesic)
crs(canopy) = crs(mesic)

mesic = resample(x = mesic, y = elev, 'near')
precip = resample(x = precip, y = elev, 'bilinear')

mesic = mask(mesic, elev)
precip = mask(precip, elev)

compareGeom(elev, precip, canopy, mesic)

probMatrix = focalMat(mesic, 1000, type='circle', fillNA=FALSE)
mesic1km = focal(mesic, probMatrix, fun='sum')

layers = c(canopy, elev, mesic, mesic1km, precip)
names(layers) = c('canopy', 'elev', 'mesic', 'mesic1km', 'precip')

layers = c(canopy, elev, mesic1km, precip)
names(layers) = c('canopy', 'elev', 'mesic1km', 'precip') # mesic was removed because of high correlation with mesic1km

set.seed(23)
backXy = data.frame(backgroundSample(layers, n=2000, p=vathPresXy))

presCovs = extract(layers, vathPresXy)
backCovs = extract(layers, backXy)
valCovs = extract(layers, vathValXy)

presCovs = data.frame(vathPresXy, presCovs, pres=1)
backCovs = data.frame(backXy, backCovs, pres=0)
valCovs = data.frame(vathValXy, valCovs)



presCovs = presCovs[complete.cases(presCovs),]
backCovs = backCovs[complete.cases(backCovs),]
valCovs = valCovs[complete.cases(valCovs),]


backCovs = backCovs %>% select(-ID)
colnames(presCovs)[1:2] = c('x', 'y')

presBackCovs = rbind(presCovs, backCovs)


tmp = presCovs %>% select(elev, precip, mesic1km, canopy) %>% 
  as.matrix()

bioclim = envelope(tmp)
```

```{r}
# Set up bioclim envelope
bioclimMap = predict(layers, bioclim)

# Set up the GLM model
glmModel = glm(pres ~ canopy + elev + I(elev^2) + mesic1km + precip, family='binomial', data=presBackCovs)
glmMap = predict(layers, glmModel, type='response')

# Set up the random forest model
tuneRF(y = as.factor(presBackCovs$pres), x=presBackCovs[,3:6], stepFactor = 2, ntreeTry = 500)
rfModel = randomForest(as.factor(pres) ~ canopy + elev + mesic1km + precip, data=presBackCovs, mtry=2, ntree=500, na.action = na.omit)
rfMap = predict(layers, rfModel, type='prob', index=2)

# Plot all maps next to one another
layers2 = c(bioclimMap, glmMap, rfMap)
names(layers2) = c('Bioclim Envelope Map', 'GLM Model Map', 'Random Forest Map')
plot(layers2)

```
**ANSWER:**

# Challenge 2 (4 points)

When we fit our GLM in lab, we used background points, rather than true absence points, to represent pseudo-absences. Fit the exact same GLM model, only this time use presence and true absence data. That is, replace the background rows in the dataframe with rows that represent actual sites where surveys were completed but Varied Thrush were not detected. Once you've fit the GLM, build a new SDM from this fitted model and visually compare the prediction surface to that built based on the presence-background model. What discrepancies do you notice, and what is your intuition regarding which of these two models is more reliable?

```{r}
absCovs = extract(layers, vathAbsXy)
absCovs = data.frame(vathAbsXy, absCovs, pres=0)
absCovs = absCovs[complete.cases(absCovs),]



colnames(absCovs)[1:2] = c('x', 'y')


```

```{r}

presAbsCovs = rbind(presCovs, absCovs)

glmModelAbs = glm(pres ~ canopy + elev + I(elev^2) + mesic1km + precip, family='binomial', data=presAbsCovs)

summary(glmModelAbs)

glmMapAbs = predict(layers, glmModelAbs, type='response')

layers3 = c(glmMap, glmMapAbs)
names(layers3) = c('GLM Map (Pseudo-absences)', 'GLM  Map (True Absences)')
plot(layers3)

```
**ANSWER:** More absences in original (2000 simulated absences v 700 true absences) drives lower overall suitability. However, distribution of true absences (and presences) are likely to be biased due to accessibility of various sampling sites. Let's visualize that.



```{r}

ggplot() +
  geom_raster(data=elev, aes(x=x, y=y, fill=elev_km)) +
  geom_point(data=backXy, aes(x=x, y=y)) +
  geom_point(data=vathPres, aes(x=EASTING, y=NORTHING), color='red', alpha=0.3) +
  geom_point(data=vathAbs, aes(x=EASTING, y=NORTHING), color = 'yellow', alpha=0.3)+
  coord_fixed()

```

**ANSWER:** Discuss distribution and overlap. Clarify which is yellow and black and red.


# Challenge 3 (4 points)

Now plot the relationship between the 4 explanatory variables and the predicted occupancy values based on the two fitted GLM models (presence-background and presence-absence). Recall that we did this in the latter part of our lab. Do you notice any differences in the covariate patterns between the two models? Does this help you interpret the discrepancies between the predicted surfaces from the two models?


```{r}
# Step 1: Generate a sequence of values for 'elevation'
elevation_seq <- seq(min(presBackCovs$elev, na.rm = TRUE), max(presBackCovs$elev, na.rm = TRUE), length.out = 100)
data_seq <- data.frame(elev = elevation_seq)

# Step 2: Predict occupancy probabilities using both GLM models for the sequence
data_seq$predPseudoAbsences <- predict(glmModel, newdata = transform(data_seq, canopy=mean(presBackCovs$canopy, na.rm=TRUE), mesic1km=mean(presBackCovs$mesic1km, na.rm=TRUE), precip=mean(presBackCovs$precip, na.rm=TRUE)), type = "response")
data_seq$predTrueAbsences <- predict(glmModelAbs, newdata = transform(data_seq, canopy=mean(presAbsCovs$canopy, na.rm=TRUE), mesic1km=mean(presAbsCovs$mesic1km, na.rm=TRUE), precip=mean(presAbsCovs$precip, na.rm=TRUE)), type = "response")


# Generate a sequence of values for 'canopy'
canopy_seq <- seq(min(presBackCovs$canopy, na.rm = TRUE), max(presBackCovs$canopy, na.rm = TRUE), length.out = 100)
data_seq_canopy <- data.frame(canopy = canopy_seq)

# Predict occupancy probabilities using both GLM models for the sequence
data_seq_canopy$predPseudoAbsences <- predict(glmModel, newdata = transform(data_seq_canopy, elev=mean(presBackCovs$elev, na.rm=TRUE), mesic1km=mean(presBackCovs$mesic1km, na.rm=TRUE), precip=mean(presBackCovs$precip, na.rm=TRUE)), type = "response")
data_seq_canopy$predTrueAbsences <- predict(glmModelAbs, newdata = transform(data_seq_canopy, elev=mean(presAbsCovs$elev, na.rm=TRUE), mesic1km=mean(presAbsCovs$mesic1km, na.rm=TRUE), precip=mean(presAbsCovs$precip, na.rm=TRUE)), type = "response")


# Generate a sequence of values for 'mesic1km'
mesic1km_seq <- seq(min(presBackCovs$mesic1km, na.rm = TRUE), max(presBackCovs$mesic1km, na.rm = TRUE), length.out = 100)
data_seq_mesic1km <- data.frame(mesic1km = mesic1km_seq)

# Predict occupancy probabilities using both GLM models for the sequence
data_seq_mesic1km$predPseudoAbsences <- predict(glmModel, newdata = transform(data_seq_mesic1km, elev=mean(presBackCovs$elev, na.rm=TRUE), canopy=mean(presBackCovs$canopy, na.rm=TRUE), precip=mean(presBackCovs$precip, na.rm=TRUE)), type = "response")
data_seq_mesic1km$predTrueAbsences <- predict(glmModelAbs, newdata = transform(data_seq_mesic1km, elev=mean(presAbsCovs$elev, na.rm=TRUE), canopy=mean(presAbsCovs$canopy, na.rm=TRUE), precip=mean(presAbsCovs$precip, na.rm=TRUE)), type = "response")


# Generate a sequence of values for 'precip'
precip_seq <- seq(min(presBackCovs$precip, na.rm = TRUE), max(presBackCovs$precip, na.rm = TRUE), length.out = 100)
data_seq_precip <- data.frame(precip = precip_seq)

# Predict occupancy probabilities using both GLM models for the sequence
data_seq_precip$predPseudoAbsences <- predict(glmModel, newdata = transform(data_seq_precip, elev=mean(presBackCovs$elev, na.rm=TRUE), mesic1km=mean(presBackCovs$mesic1km, na.rm=TRUE), canopy=mean(presBackCovs$canopy, na.rm=TRUE)), type = "response")
data_seq_precip$predTrueAbsences <- predict(glmModelAbs, newdata = transform(data_seq_precip, elev=mean(presAbsCovs$elev, na.rm=TRUE), mesic1km=mean(presAbsCovs$mesic1km, na.rm=TRUE), canopy=mean(presAbsCovs$canopy, na.rm=TRUE)), type = "response")



# Adjusted plot definitions with custom legend title
plot_elevation <- ggplot(data_seq, aes(x = elev)) +
  geom_line(aes(y = predPseudoAbsences, colour = "Pseudo-Absences")) +
  geom_line(aes(y = predTrueAbsences, colour = "True Absences")) +
  labs(x = "Elevation", y = "Value", colour = "GLM Type") +
  scale_colour_manual(values = c("Pseudo-Absences" = "blue", "True Absences" = "red")) +
  theme_minimal() +
  ggtitle("Elevation")

plot_canopy <- ggplot(data_seq_canopy, aes(x = canopy)) +
  geom_line(aes(y = predPseudoAbsences, colour = "Pseudo-Absences")) +
  geom_line(aes(y = predTrueAbsences, colour = "True Absences")) +
  labs(x = "Canopy", y = "Value", colour = "GLM Type") +
  scale_colour_manual(values = c("Pseudo-Absences" = "blue", "True Absences" = "red")) +
  theme_minimal() +
  ggtitle("Canopy")

plot_mesic1km <- ggplot(data_seq_mesic1km, aes(x = mesic1km)) +
  geom_line(aes(y = predPseudoAbsences, colour = "Pseudo-Absences")) +
  geom_line(aes(y = predTrueAbsences, colour = "True Absences")) +
  labs(x = "Mesic1km", y = "Value", colour = "GLM Type") +
  scale_colour_manual(values = c("Pseudo-Absences" = "blue", "True Absences" = "red")) +
  theme_minimal() +
  ggtitle("Mesic1km")

plot_precip <- ggplot(data_seq_precip, aes(x = precip)) +
  geom_line(aes(y = predPseudoAbsences, colour = "Pseudo-Absences")) +
  geom_line(aes(y = predTrueAbsences, colour = "True Absences")) +
  labs(x = "Precipitation", y = "Value", colour = "GLM Type") +
  scale_colour_manual(values = c("Pseudo-Absences" = "blue", "True Absences" = "red")) +
  theme_minimal() +
  ggtitle("Precipitation")

# Combine the plots with the adjusted legend title
combined_plot <- plot_elevation + plot_canopy + plot_mesic1km + plot_precip +
  plot_layout(ncol = 2)

# Print the combined plot with the adjusted legend title
combined_plot




```



**ANSWER:**

# Challenge 4 (4 points)

Varied Thrush are considered forest-dependent, and thus one might characterize mesic forests as "habitat" for the species. Calculate the total amount of mesic forest in the study area, and the mean size of the mesic forest patches.

Using the SDM built from the random forest model, convert the landscape into "habitat" and "non-habitat." To do this, choose a threshold value in your SDM and convert all cells with predicted outcomes greater than this threshold to 1 and all cells with predicted values below your threshold to 0. Justify your choice of your threshold value. Now calculate the total amount of habitat and mean size of habitat patches based on this new raster (i.e., create patches of "habitat" based on aggregations of cells you deemed 1). How do the habitat amount and patch size values compare between the mesic forest approach and the SDM-based approach? In what situations might you rely on one map over the other?

```{r}

# Plot Mesic Forest
mesic_binary <- ifel(mesic == 1, 1, 0)
plot(mesic_binary, main="Binary Mesic Forest Raster", col=c("white", "green"), legend=TRUE, axes=TRUE)

# Mesic Forest Patches
mesic_patches <- patches(mesic_binary, directions=8, zeroAsNA=T)
plot(mesic_patches, main="Mesic Patches", legend=TRUE)

# Calculate total area of mesic forest

# Sum mesic forest values
mesic_forest_cells <- sum(values(mesic) == 1, na.rm = TRUE)
non_mesic_forest_cells <- sum(values(mesic) != 1, na.rm = TRUE)
mesic_percent_rounded <- round((mesic_forest_cells/(mesic_forest_cells+non_mesic_forest_cells)*100),2)

# Calculate the area of a single cell (in square meters)
cell_area_square_meters <- res(mesic)[1] * res(mesic)[2]  # Cell resolution (width * height) = 200 m x 200 m
cell_area_sqkm <- cell_area_square_meters/1000000 # Convert to square kilometers

# Calculate total mesic forest area
total_mesic_area <- mesic_forest_cells * cell_area_sqkm

# Calculate mean patch size
mesic_patch_areas <- table(values(mesic_patches))
mesic_mean_patch_size_sqkm <- mean(mesic_patch_areas * cell_area_sqkm)
mesic_mean_patch_size_roundedsqkm <- round(mesic_mean_patch_size_sqkm, 2)

print(paste("In our study area, mesic forest covers",  total_mesic_area, "square kilometers, which accounts for", mesic_percent_rounded, "% of the study area."))
# Output results
print(paste("Furthermore, the mean patch size of mesic forest is", mesic_mean_patch_size_roundedsqkm, "square kilometers."))


```
Now calculate the total amount of habitat and mean size of habitat patches based on this new raster (i.e., create patches of "habitat" based on aggregations of cells you deemed 1). How do the habitat amount and patch size values compare between the mesic forest approach and the SDM-based approach? In what situations might you rely on one map over the other?

```{r}

# Plot Habitat Threshold above 0.5 & apply threshold to convert probabilities to binary habitat classification
rf_binary <- ifel(rfMap > 0.5, 1, 0)
plot(rf_binary, main="Binary rf Habitat Raster", col=c("white", "green"), legend=TRUE, axes=TRUE)

# Step 2: Identify habitat patches
habitat_patches <- patches(rf_binary, directions=8, zeroAsNA=T)
plot(habitat_patches, main="Habitat Patches", legend=TRUE)


# Calculate total habitat area 
cell_area <- res(rf_binary)[1] * res(rf_binary)[2] # Cell resolution (width * height)
total_habitat_area_sqkm <- (sum(values(rf_binary) == 1, na.rm = TRUE) * cell_area_sqkm) # Convert square km

# Calculate mean patch size
patch_areas <- table(values(habitat_patches))
mean_patch_size_sqkm <- (mean(patch_areas * cell_area_sqkm))
mean_patch_size_roundedsqkm <- round(mean_patch_size_sqkm, 2)

# Output results
print(paste("According to the random forest model (with a >0.5 threshold for habitat), the total habitat area is", total_habitat_area_sqkm, "square kilometers, while the mean patch size is", mean_patch_size_roundedsqkm, "square kilometers."))


```

**ANSWER:** Discuss how rf model is much smaller. How patch sizes are tiny, especially compared to mesic forest.



# Challenge 5 (4 points)

When we fit the Maxent model in the lab, we used a regularization constant of 1. Fit the model two more times, using regularization (regmult) constants of 0.5 and 3. Construct figures showing the relationship between the 4 explanatory variables and the predicted outcome from these 3 fitted Maxent models. What is the regularization constant doing? Hint: you may need to Google it.

```{r}
#Place code here
pbVect = presBackCovs$pres
covs = presBackCovs %>% select(canopy:precip)

maxentModel.5 = maxnet(p = pbVect,
                     data= covs,
                     regmult = 0.5,
                     classes='lqpht')

maxentModel = maxnet(p = pbVect,
                     data= covs,
                     regmult = 1,
                     classes='lqpht')

maxentModel3 = maxnet(p = pbVect,
                     data= covs,
                     regmult = 3,
                     classes='lqpht')

plot(maxentModel.5, type='logistic')
plot(maxentModel, type='logistic')
plot(maxentModel3, type='logistic')



tmp = expand.grid(elev = seq(min(backCovs$elev), max(backCovs$elev), length=1000),
                  canopy = mean(backCovs$canopy),
                  precip = mean(backCovs$precip),
                  mesic1km = mean(backCovs$mesic1km))

elevData = data.frame(elev = tmp$elev,
                      maxent.5 = predict(maxentModel.5, tmp, type='logistic')[,1],
                      maxent = predict(maxentModel, tmp, type='logistic')[,1],
                      maxent3 = predict(maxentModel3, tmp, type='logistic')[,1]) %>%
  pivot_longer(-elev, names_to = "model", values_to = "prediction") %>%
  mutate(variable = 'elevation')

tmp = expand.grid(elev = mean(backCovs$elev),
                  canopy = seq(min(backCovs$canopy), max(backCovs$canopy), length=1000),
                  precip = mean(backCovs$precip),
                  mesic1km = mean(backCovs$mesic1km))

canopyData = data.frame(canopy = tmp$canopy,
                        maxent.5 = predict(maxentModel.5, tmp, type='logistic')[,1],
                        maxent = predict(maxentModel, tmp, type='logistic')[,1],
                        maxent3 = predict(maxentModel3, tmp, type='logistic')[,1]) %>%
  pivot_longer(-canopy, names_to = "model", values_to = "prediction") %>%
  mutate(variable = 'canopy')

tmp = expand.grid(elev = mean(backCovs$elev),
                  canopy = mean(backCovs$canopy),
                  precip = seq(min(backCovs$precip), max(backCovs$precip), length=1000),
                  mesic1km = mean(backCovs$mesic1km))

precipData = data.frame(precip = tmp$precip,
                        maxent.5 = predict(maxentModel.5, tmp, type='logistic')[,1],
                        maxent = predict(maxentModel, tmp, type='logistic')[,1],
                        maxent3 = predict(maxentModel3, tmp, type='logistic')[,1]) %>%
  pivot_longer(-precip, names_to = "model", values_to = "prediction") %>%
  mutate(variable = 'precipitation')

tmp = expand.grid(elev = mean(backCovs$elev),
                  canopy = mean(backCovs$canopy),
                  precip = mean(backCovs$precip),
                  mesic1km = seq(min(backCovs$mesic1km), max(backCovs$mesic1km), length=1000))

mesicData = data.frame(mesic1km = tmp$mesic1km,
                        maxent.5 = predict(maxentModel.5, tmp, type='logistic')[,1],
                        maxent = predict(maxentModel, tmp, type='logistic')[,1],
                        maxent3 = predict(maxentModel3, tmp, type='logistic')[,1]) %>%
  pivot_longer(-mesic1km, names_to = "model", values_to = "prediction") %>%
  mutate(variable = 'mesic1km')

colnames(elevData)[1] = colnames(canopyData)[1] = colnames(precipData)[1] = colnames(mesicData)[1] = 'xValue'
combined_data = rbind(elevData, canopyData, precipData, mesicData)

ggplot(combined_data, aes(x=xValue, y=prediction, color=model))+
  facet_wrap(~variable, scales='free_x')+
  geom_line()+
  theme_bw()+
  theme(panel.grid=element_blank())



```

**ANSWER:** The higher it is, the more the trend appears smoothed out.

